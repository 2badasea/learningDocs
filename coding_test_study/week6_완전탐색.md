# 6장 완전탐색(Brute Force) 핵심 요약 (발표용)

## 1) 완전탐색이란?
- **문제 조건을 만족하는 “모든 경우”를 빠짐없이 확인**해서 정답을 찾는 방법
- 구현만 정확하면 **정답을 100% 보장**(정확성이 가장 큰 장점)
- 단, “모든 경우”를 보기 때문에 **시간 복잡도(경우의 수)가 핵심 리스크**

---

## 2) 완전탐색 적용 판단 기준: 시간 복잡도(= 탐색 공간 크기)
- 완전탐색의 실행 시간은 보통  
  **탐색해야 할 상태(경우)의 개수 × 상태 처리 비용**에 비례
- 따라서 적용 전 반드시:
  - “가능한 경우의 수가 얼마나 되는지”
  - “제한 시간 안에 다 돌 수 있는지”
  를 계산/추정해야 함
- **경우의 수가 충분히 작으면** 오히려 완전탐색이 가장 깔끔하고 안전한 풀이가 될 수 있음

---

## 3) 상태(State)와 상태 전이(Transition)
### 상태(State)
- 완전탐색이 진행되는 “현재 상황”을 표현하는 값들의 묶음
- 상태는 보통 **변수(좌표, 인덱스, 선택 집합 등)**로 표현

### 상태 전이(Transition)
- 한 상태에서 다음 상태로 이동하는 규칙(가능한 선택/이동)
- 완전탐색은 **상태를 전이시키며 모든 경로/경우를 탐색**하는 과정

---

## 4) 상태 정의가 중요한 이유 (불필요한 변수 = 탐색 폭발)
- 상태에 **불필요한 변수**가 들어가면 탐색 공간이 불필요하게 커짐
- 예시(2차원 이동):
  - 상태를 (x, y)로 정의하면 다음 상태는 보통 4방향:  
    (x, y-1), (x, y+1), (x-1, y), (x+1, y)
  - 그런데 불필요하게 z까지 포함해 (x, y, z)로 잡으면  
    (x, y, z-1), (x, y, z+1) 같은 전이가 추가되어 **탐색 분기 수 증가**
- 결론: **문제에 필요한 최소 상태만 설계**하는 게 완전탐색의 성능을 좌우

---

## 5) 완전탐색의 대표 구현 유형
### (1) 간단히 구현되는 완전탐색
- 경우의 수가 매우 작으면 **중첩 for문만으로도** 전수 조사 가능
- “조합/순열/선택”을 직접 돌며 조건 검사하는 형태

### (2) DFS (Depth First Search, 깊이 우선 탐색)
- 한 경로를 **끝까지 깊게** 들어간 뒤, 막히면 되돌아오는 방식(Backtracking 느낌)
- 보통 **재귀**로 구현하기 쉬움
- 특징: “한 가지 전이를 더 이상 못 할 때까지” 연속 적용하는 흐름

### (3) BFS (Breadth First Search, 너비 우선 탐색)
- 현재 상태에서 갈 수 있는 **다음 단계 상태들을 먼저 전부 방문**한 뒤,
  그 다음 단계로 넘어가는 방식
- 보통 **큐(Queue)**로 구현
- 특징: “레벨(거리/단계) 단위로” 탐색이 진행됨

---

## 6) 방문 처리(Visited): 왜 필요하고, 언제 꼭 필요한가?
- 완전탐색의 시간 복잡도는 **탐색 공간(상태 수)**에 비례
- 그런데 **같은 상태를 여러 번 재방문**하면:
  - 동일한 하위 탐색을 반복하게 되어
  - 시간 복잡도가 **기하급수적으로 증가**할 수 있음
- 특히 **DFS/BFS로 그래프/격자/상태공간**을 탐색할 때는
  - 같은 상태를 다시 큐/스택에 넣는 일이 흔해서
  - **Visited(방문 체크)**가 사실상 필수

### 핵심 메시지
- “상태 수가 작아 보여도”
- **중복 방문이 생기면 실제 탐색**
